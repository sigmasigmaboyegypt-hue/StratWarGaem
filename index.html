<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Circle Battle Simulator</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;}
html,body{width:100%;height:100%;overflow:hidden;font-family:'Segoe UI',sans-serif;background:#121212;color:white;display:flex;flex-direction:column;}
.header{width:100%;padding:10px 20px;background:#1a1a1a;border-bottom:1px solid #333;display:flex;justify-content:space-between;align-items:center;}
.header h1{font-size:1.5rem;color:#f1c40f;}
.controls{display:flex;gap:10px;}
button{padding:5px 10px;border:none;border-radius:5px;cursor:pointer;font-weight:bold;transition:0.2s;}
button:hover{opacity:0.8;}
#startBtn{background:#2ecc71;color:#121212;}
#pauseBtn{background:#e67e22;color:#121212;}
#teamRed{background:#e74c3c;color:white;}
#teamBlue{background:#3498db;color:white;}
.stats{display:flex;gap:20px;padding:10px;background:#1a1a1a;}
canvas{flex:1;background:#181818;display:block;cursor:pointer;}
</style>
</head>
<body>

<div class="header">
    <h1>Circle Battle Simulator</h1>
    <div class="controls">
        <button id="teamRed">Red</button>
        <button id="teamBlue">Blue</button>
        <button id="startBtn">Start</button>
        <button id="pauseBtn">Pause</button>
    </div>
</div>

<div class="stats">
    <div>Red: <span id="redCount">0</span></div>
    <div>Blue: <span id="blueCount">0</span></div>
    <div>Time: <span id="gameTime">0</span>s</div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas=document.getElementById('gameCanvas');
const ctx=canvas.getContext('2d');
canvas.width=window.innerWidth;
canvas.height=window.innerHeight-document.querySelector('.header').offsetHeight-document.querySelector('.stats').offsetHeight;

let circles=[];
let selectedCircle=null;
let placingTeam='red';
let running=false;
let gameTime=0;
let lastTime=Date.now();

const redCountEl=document.getElementById('redCount');
const blueCountEl=document.getElementById('blueCount');
const gameTimeEl=document.getElementById('gameTime');
const startBtn=document.getElementById('startBtn');
const pauseBtn=document.getElementById('pauseBtn');

document.getElementById('teamRed').addEventListener('click',()=>placingTeam='red');
document.getElementById('teamBlue').addEventListener('click',()=>placingTeam='blue');
startBtn.addEventListener('click',()=>running=true);
pauseBtn.addEventListener('click',()=>running=false);

class Circle{
    constructor(x,y,team){
        this.x=x;
        this.y=y;
        this.team=team;
        this.radius=20;
        this.maxHealth=100;
        this.health=this.maxHealth;
        this.speed=2;
        this.attackPower=10;
        this.controlledByPlayer=false;
        this.targetX=null;
        this.targetY=null;
        this.attackCooldown=0;
        this.encircleAngle=Math.random()*Math.PI*2; // For AI encirclement
    }
    draw(){
        ctx.beginPath();
        ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);
        ctx.fillStyle=this.team==='red'?'#e74c3c':'#3498db';
        ctx.fill();
        if(this===selectedCircle){
            ctx.strokeStyle='#f1c40f';
            ctx.lineWidth=3;
            ctx.stroke();
        }
        // Health bar
        ctx.fillStyle='#333';
        ctx.fillRect(this.x-25,this.y-this.radius-15,50,8);
        const hpRatio=this.health/this.maxHealth;
        ctx.fillStyle=hpRatio>0.6?'#2ecc71':hpRatio>0.3?'#f39c12':'#e74c3c';
        ctx.fillRect(this.x-25,this.y-this.radius-15,50*hpRatio,8);
        ctx.strokeStyle='#fff';
        ctx.strokeRect(this.x-25,this.y-this.radius-15,50,8);
    }
    move(){
        if(this.controlledByPlayer){
            if(this.targetX!==null&&this.targetY!==null){
                const dx=this.targetX-this.x;
                const dy=this.targetY-this.y;
                const dist=Math.sqrt(dx*dx+dy*dy);
                if(dist>this.speed){
                    this.x+=dx/dist*this.speed;
                    this.y+=dy/dist*this.speed;
                }else{
                    this.x=this.targetX;
                    this.y=this.targetY;
                    this.targetX=null;
                    this.targetY=null;
                }
            }
        }else{
            // AI finds nearest enemy
            let targets=circles.filter(c=>c.team!==this.team);
            if(targets.length>0){
                let nearest=null;
                let minDist=Infinity;
                for(const t of targets){
                    const dx=t.x-this.x;
                    const dy=t.y-this.y;
                    const d=Math.sqrt(dx*dx+dy*dy);
                    if(d<minDist){
                        minDist=d;
                        nearest=t;
                    }
                }
                if(nearest){
                    // Encirclement: spread units around enemy
                    const allies=circles.filter(c=>c.team===this.team && c!==this);
                    const index=allies.indexOf(this);
                    const angle=index/allies.length*Math.PI*2;
                    const offsetX=Math.cos(angle)*25;
                    const offsetY=Math.sin(angle)*25;
                    const targetX=nearest.x+offsetX;
                    const targetY=nearest.y+offsetY;

                    const dx=targetX-this.x;
                    const dy=targetY-this.y;
                    const dist=Math.sqrt(dx*dx+dy*dy);
                    if(dist>0){
                        this.x+=dx/dist*this.speed;
                        this.y+=dy/dist*this.speed;
                    }
                }
            }
        }

        if(this.attackCooldown>0)this.attackCooldown--;
    }
    attack(enemy){
        if(this.attackCooldown===0){
            enemy.health-=this.attackPower;
            this.attackCooldown=30;
        }
    }
    isColliding(other){
        const dx=this.x-other.x;
        const dy=this.y-other.y;
        return Math.sqrt(dx*dx+dy*dy)<this.radius+other.radius;
    }
}

// Simple collision resolution
function resolveCollisions(){
    for(let i=0;i<circles.length;i++){
        for(let j=i+1;j<circles.length;j++){
            const c1=circles[i];
            const c2=circles[j];
            const dx=c2.x-c1.x;
            const dy=c2.y-c1.y;
            const dist=Math.sqrt(dx*dx+dy*dy);
            const minDist=c1.radius+c2.radius;
            if(dist<minDist && dist>0){
                const overlap=(minDist-dist)/2;
                c1.x-=dx/dist*overlap;
                c1.y-=dy/dist*overlap;
                c2.x+=dx/dist*overlap;
                c2.y+=dy/dist*overlap;
            }
        }
    }
}

function spawnCircle(x,y,team){
    circles.push(new Circle(x,y,team));
    updateCounts();
}

function updateCounts(){
    const reds=circles.filter(c=>c.team==='red').length;
    const blues=circles.filter(c=>c.team==='blue').length;
    redCountEl.textContent=reds;
    blueCountEl.textContent=blues;
}

canvas.addEventListener('click',(e)=>{
    const rect=canvas.getBoundingClientRect();
    const x=e.clientX-rect.left;
    const y=e.clientY-rect.top;
    let clicked=null;
    for(let i=circles.length-1;i>=0;i--){
        const c=circles[i];
        const dx=c.x-x;
        const dy=c.y-y;
        if(Math.sqrt(dx*dx+dy*dy)<c.radius){
            clicked=c;
            break;
        }
    }
    if(clicked){
        if(selectedCircle)selectedCircle.controlledByPlayer=false;
        selectedCircle=clicked;
        selectedCircle.controlledByPlayer=true;
    }else if(selectedCircle && running){
        selectedCircle.targetX=x;
        selectedCircle.targetY=y;
    }else if(!running){
        spawnCircle(x,y,placingTeam);
    }
});

function gameLoop(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if(running){
        for(const c of circles)c.move();
        resolveCollisions();
        // Attack collisions
        for(let i=0;i<circles.length;i++){
            for(let j=i+1;j<circles.length;j++){
                if(circles[i].team!==circles[j].team && circles[i].isColliding(circles[j])){
                    circles[i].attack(circles[j]);
                    circles[j].attack(circles[i]);
                }
            }
        }
        // Remove dead
        circles=circles.filter(c=>c.health>0);
        updateCounts();
        const now=Date.now();
        gameTime+=(now-lastTime)/1000;
        lastTime=now;
        gameTimeEl.textContent=Math.floor(gameTime);
    }else{
        lastTime=Date.now();
    }
    for(const c of circles)c.draw();
    requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
