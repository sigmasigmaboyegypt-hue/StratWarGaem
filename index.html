<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Circle Battle Simulator - Modern Map</title>
<style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body { font-family:'Segoe UI',sans-serif; background:#121212; color:#fff; overflow:hidden; }

    .header {
        display:flex; justify-content:space-between; align-items:center;
        padding:10px 20px; background:#1f1f1f;
        box-shadow:0 4px 10px rgba(0,0,0,0.5);
    }
    .header h1 { color:#f1c40f; font-size:1.5rem; }
    .header .buttons { display:flex; gap:10px; }
    .header button {
        border:none; padding:6px 14px; border-radius:5px;
        font-weight:bold; cursor:pointer; transition:0.2s;
    }
    .red-btn{background:#e74c3c;} .blue-btn{background:#3498db;}
    .delete-btn{background:#7f8c8d;} .start-btn{background:#2ecc71;}
    .pause-btn{background:#e67e22;}
    .header button:hover{filter:brightness(1.2);}

    #placingNotification {
        position:absolute; top:60px; left:50%; transform:translateX(-50%);
        background:#333; padding:5px 12px; border-radius:5px;
        font-weight:bold; color:#f1c40f;
        box-shadow:0 2px 8px rgba(0,0,0,0.7);
    }

    #gameCanvas {
        display:block; margin:80px auto 0 auto;
        background:linear-gradient(135deg,#1a1a1a,#2a2a2a);
        border-radius:10px; box-shadow:0 0 20px rgba(0,0,0,0.7);
    }
</style>
</head>
<body>

<div class="header">
    <h1>Circle Battle Simulator</h1>
    <div class="buttons">
        <button class="red-btn" id="placeRed">Red</button>
        <button class="blue-btn" id="placeBlue">Blue</button>
        <button class="delete-btn" id="deleteTool">Delete</button>
        <button class="start-btn" id="startBtn">Start</button>
        <button class="pause-btn" id="pauseBtn">Pause</button>
    </div>
</div>

<div id="placingNotification">Placing: Red</div>
<canvas id="gameCanvas" width="1000" height="600"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const placingNotification = document.getElementById("placingNotification");

let placingMode = "red";
let gameRunning = false;
let circles = [];

// ghost placement
let mouseX = 0, mouseY = 0;
let showGhost = true;

canvas.addEventListener("mousemove", e => {
    const rect = canvas.getBoundingClientRect();
    mouseX = e.clientX - rect.left;
    mouseY = e.clientY - rect.top;
});

class Circle {
    constructor(x, y, team) {
        this.x = x;
        this.y = y;
        this.team = team;
        this.radius = 20;
        this.health = 100;
        this.speed = team === "red" ? 1.8 : 2;
        this.attackPower = team === "red" ? 10 : 12;
        this.attackCooldown = 400; // ms
        this.lastAttack = 0;
    }

    draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.team === "red" ? "#e74c3c" : "#3498db";
        ctx.fill();

        // health bar
        ctx.fillStyle = "#333";
        ctx.fillRect(this.x - 25, this.y - this.radius - 15, 50, 8);

        ctx.fillStyle =
            this.health > 60 ? "#2ecc71" :
            this.health > 30 ? "#f39c12" : "#e74c3c";

        ctx.fillRect(this.x - 25, this.y - this.radius - 15, 50 * (this.health / 100), 8);

        ctx.strokeStyle = "#fff";
        ctx.strokeRect(this.x - 25, this.y - this.radius - 15, 50, 8);
    }

    distanceTo(other) {
        return Math.hypot(this.x - other.x, this.y - other.y);
    }

    moveToward(target) {
        let dx = target.x - this.x;
        let dy = target.y - this.y;
        let dist = Math.hypot(dx, dy);

        if (dist > this.radius + target.radius + 5) {
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
        }
    }

    attack(target) {
        let now = performance.now();
        let dist = this.distanceTo(target);

        // improved attack range so hugging never stops combat
        if (dist <= this.radius + target.radius + 4) {
            if (now - this.lastAttack >= this.attackCooldown) {
                target.health -= this.attackPower;
                this.lastAttack = now;
            }
        }
    }

    resolveCollision(other) {
        let dx = this.x - other.x;
        let dy = this.y - other.y;
        let dist = Math.hypot(dx, dy);
        let minDist = this.radius + other.radius + 1;

        if (dist < minDist && dist > 0) {
            let overlap = minDist - dist;
            let pushX = (dx / dist) * (overlap * 0.6);
            let pushY = (dy / dist) * (overlap * 0.6);

            this.x += pushX;
            this.y += pushY;
            other.x -= pushX;
            other.y -= pushY;
        }
    }
}

function drawMap() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = "rgba(255,255,255,0.05)";

    for (let x = 0; x <= canvas.width; x += 50) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
    }
    for (let y = 0; y <= canvas.height; y += 50) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
    }

    ctx.fillStyle = "rgba(231,76,60,0.1)";
    ctx.fillRect(0, 0, 100, canvas.height);
    ctx.fillStyle = "rgba(52,152,219,0.1)";
    ctx.fillRect(canvas.width - 100, 0, 100, canvas.height);
}

function drawGhost() {
    if (!showGhost) return;
    if (placingMode !== "red" && placingMode !== "blue") return;

    let color = "rgba(255,255,255,0.45)";

    // check if ghost collides with existing units
    let blocked = circles.some(c => Math.hypot(c.x - mouseX, c.y - mouseY) < c.radius * 2);

    if (blocked) color = "rgba(255,0,0,0.45)";

    ctx.beginPath();
    ctx.arc(mouseX, mouseY, 20, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
}

function gameLoop() {
    drawMap();
    drawGhost();

    if (gameRunning) {
        circles.forEach(c => {
            let enemies = circles.filter(e => e.team !== c.team && e.health > 0);

            if (enemies.length > 0) {
                let target = enemies.reduce((a, b) =>
                    c.distanceTo(a) < c.distanceTo(b) ? a : b
                );

                c.moveToward(target);
                c.attack(target);
            }
        });

        // resolve all collisions
        for (let i = 0; i < circles.length; i++) {
            for (let j = i + 1; j < circles.length; j++) {
                circles[i].resolveCollision(circles[j]);
            }
        }
    }

    circles = circles.filter(c => c.health > 0);
    circles.forEach(c => c.draw());

    requestAnimationFrame(gameLoop);
}

canvas.addEventListener("click", e => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (placingMode === "red" || placingMode === "blue") {

        // prevent placing in same spot
        let blocked = circles.some(c => Math.hypot(c.x - x, c.y - y) < c.radius * 2);

        if (!blocked) circles.push(new Circle(x, y, placingMode));

    } else if (placingMode === "delete") {
        circles = circles.filter(c => Math.hypot(c.x - x, c.y - y) > c.radius);
    }
});

document.getElementById("placeRed").onclick = () => {
    placingMode = "red";
    placingNotification.textContent = "Placing: Red";
    showGhost = true;
};

document.getElementById("placeBlue").onclick = () => {
    placingMode = "blue";
    placingNotification.textContent = "Placing: Blue";
    showGhost = true;
};

document.getElementById("deleteTool").onclick = () => {
    placingMode = "delete";
    placingNotification.textContent = "Delete Tool Active";
    showGhost = false;
};

document.getElementById("startBtn").onclick = () => {
    gameRunning = true;
    showGhost = false;
};

document.getElementById("pauseBtn").onclick = () => {
    gameRunning = false;
    showGhost = true;
};

gameLoop();
</script>
</body>
</html>
