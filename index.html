<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Circle Battle: Player vs AI</title>
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
    body {
        background: linear-gradient(135deg, #1a2a6c, #2c3e50);
        display: flex; flex-direction: column; align-items: center;
        justify-content: flex-start;
        color: white;
    }
    .header { text-align: center; margin: 10px; flex-shrink: 0; }
    h1 {
        font-size: 2rem;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        background: linear-gradient(to right, #3498db, #e74c3c);
        -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    }
    .subtitle { font-size: 1rem; margin-top: 5px; color: #ecf0f1; }
    .game-container {
        flex: 1; width: 100%; display: flex; flex-direction: column;
        align-items: center; justify-content: flex-start;
    }
    canvas {
        background-color: #2c3e50; border-radius: 10px;
        box-shadow: 0 0 20px rgba(0,0,0,0.5);
    }
    .controls, .difficulty-controls { display: flex; gap: 10px; margin-top: 5px; flex-wrap: wrap; justify-content: center; flex-shrink: 0; }
    button {
        background: #3498db; color: white; border: none; padding: 5px 10px;
        border-radius: 5px; cursor: pointer; font-weight: bold; transition: all 0.3s;
    }
    button:hover { transform: translateY(-1px); }
    button:active { transform: translateY(1px); }
    #spawnRed { background: #e74c3c; }
    #clearAll { background: #e67e22; }
    .difficulty-btn.active-difficulty { background: #f1c40f; color: #2c3e50; }
    .stats { display: flex; gap: 20px; justify-content: center; margin-top: 5px; flex-shrink: 0; }
    .stat { text-align: center; font-size: 0.9rem; }
    .stat-value { font-size: 1.2rem; font-weight: bold; color: #f1c40f; }
</style>
</head>
<body>
<div class="header">
    <h1>Circle Battle: Player vs AI</h1>
    <p class="subtitle">Click to select blue circles and move them</p>
</div>

<div class="game-container">
    <canvas id="gameCanvas"></canvas>

    <div class="controls">
        <button id="spawnBlue">Spawn Player</button>
        <button id="spawnRed">Spawn AI</button>
        <button id="clearAll">Clear All</button>
    </div>

    <div class="difficulty-controls">
        <button id="easy" class="difficulty-btn">Easy</button>
        <button id="medium" class="difficulty-btn active-difficulty">Medium</button>
        <button id="hard" class="difficulty-btn">Hard</button>
    </div>

    <div class="stats">
        <div class="stat"><div class="stat-value" id="blueCount">0</div>Player</div>
        <div class="stat"><div class="stat-value" id="redCount">0</div>AI</div>
        <div class="stat"><div class="stat-value" id="playerKills">0</div>Kills</div>
        <div class="stat"><div class="stat-value" id="aiKills">0</div>AI Kills</div>
        <div class="stat"><div class="stat-value" id="gameTime">0</div>Seconds</div>
    </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let canvasWidth = window.innerWidth;
let canvasHeight = window.innerHeight - document.querySelector('.header').offsetHeight - 150;
canvas.width = canvasWidth;
canvas.height = canvasHeight;

window.addEventListener('resize', ()=>{
    canvasWidth = window.innerWidth;
    canvasHeight = window.innerHeight - document.querySelector('.header').offsetHeight - 150;
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
});

const blueCountElement = document.getElementById('blueCount');
const redCountElement = document.getElementById('redCount');
const playerKillsElement = document.getElementById('playerKills');
const aiKillsElement = document.getElementById('aiKills');
const gameTimeElement = document.getElementById('gameTime');
const spawnBlueButton = document.getElementById('spawnBlue');
const spawnRedButton = document.getElementById('spawnRed');
const clearAllButton = document.getElementById('clearAll');
const difficultyButtons = {
    easy: document.getElementById('easy'),
    medium: document.getElementById('medium'),
    hard: document.getElementById('hard')
};

let circles = [];
let selectedCircle = null;
let playerKills = 0;
let aiKills = 0;
let gameTime = 0;
let gameStartTime = Date.now();
let difficulty = 'medium';

class Circle{
    constructor(x,y,team){
        this.x=x; this.y=y; this.team=team; this.radius=20; this.maxHealth=100; this.health=100;
        this.speed = (team==='blue'?2.5:(difficulty==='easy'?1.5:(difficulty==='medium'?2:2.2)));
        this.attackPower = (team==='blue'?12:(difficulty==='easy'?8:(difficulty==='medium'?10:12)));
        this.targetX = null; this.targetY = null; this.isMoving=false; this.attackCooldown=0;
        this.aiState='wander'; this.aiTarget=null; this.wanderDirection=Math.random()*Math.PI*2; this.wanderChange=0;
    }

    draw(){
        ctx.beginPath();
        ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);
        ctx.fillStyle = this.team==='blue'?'#3498db':'#e74c3c';
        ctx.fill();
        if(this===selectedCircle){ ctx.strokeStyle='#f1c40f'; ctx.lineWidth=3; ctx.stroke(); }
        ctx.fillStyle='#333';
        ctx.fillRect(this.x-25,this.y-this.radius-15,50,8);
        const hpPercent=this.health/this.maxHealth;
        ctx.fillStyle=hpPercent>0.6?'#2ecc71':hpPercent>0.3?'#f39c12':'#e74c3c';
        ctx.fillRect(this.x-25,this.y-this.radius-15,50*hpPercent,8);
        ctx.strokeStyle='#fff'; ctx.lineWidth=1; ctx.strokeRect(this.x-25,this.y-this.radius-15,50,8);
    }

    move(){
        if(this.team==='blue'){
            if(this.isMoving && this.targetX!==null && this.targetY!==null){
                const dx=this.targetX-this.x; const dy=this.targetY-this.y;
                const dist=Math.sqrt(dx*dx+dy*dy);
                if(dist>this.speed){ this.x+=dx/dist*this.speed; this.y+=dy/dist*this.speed; }
                else{ this.x=this.targetX; this.y=this.targetY; this.isMoving=false; }
            }
        }else{ this.updateAI(); }
        if(this.attackCooldown>0) this.attackCooldown--;
    }

    updateAI(){
        let nearest=null; let nearestDist=Infinity;
        for(const c of circles){ if(c.team==='blue'){ const dx=c.x-this.x; const dy=c.y-this.y; const dist=Math.sqrt(dx*dx+dy*dy); if(dist<nearestDist){nearestDist=dist;nearest=c;} } }
        if(nearest){
            if(nearestDist<50){ this.aiState='attack'; this.aiTarget=nearest; }
            else if(nearestDist<200){ this.aiState='chase'; this.aiTarget=nearest; this.targetX=nearest.x; this.targetY=nearest.y; }
            else{ this.aiState='wander'; this.aiTarget=null; }
        }else{ this.aiState='wander'; this.aiTarget=null; }

        if(this.aiState==='chase' && this.aiTarget){
            const dx=this.targetX-this.x; const dy=this.targetY-this.y; const dist=Math.sqrt(dx*dx+dy*dy);
            if(dist>this.speed){ this.x+=dx/dist*this.speed; this.y+=dy/dist*this.speed; }
        }else if(this.aiState==='wander'){
            this.wanderChange--;
            if(this.wanderChange<=0){ this.wanderDirection+=(Math.random()-0.5)*Math.PI; this.wanderChange=30+Math.random()*30; }
            this.x+=Math.cos(this.wanderDirection)*this.speed*0.7; this.y+=Math.sin(this.wanderDirection)*this.speed*0.7;
            if(this.x<this.radius){ this.x=this.radius; this.wanderDirection=Math.PI-this.wanderDirection; }
            else if(this.x>canvas.width-this.radius){ this.x=canvas.width-this.radius; this.wanderDirection=Math.PI-this.wanderDirection; }
            if(this.y<this.radius){ this.y=this.radius; this.wanderDirection=-this.wanderDirection; }
            else if(this.y>canvas.height-this.radius){ this.y=canvas.height-this.radius; this.wanderDirection=-this.wanderDirection; }
        }
    }

    setTarget(x,y){ this.targetX=x; this.targetY=y; this.isMoving=true; }

    attack(enemy){
        if(this.attackCooldown===0){ enemy.health-=this.attackPower; this.attackCooldown=30;
            if(enemy.health<=0){ if(this.team==='blue'){ playerKills++; playerKillsElement.textContent=playerKills; }else{ aiKills++; aiKillsElement.textContent=aiKills; } }
        }
    }

    isCollidingWith(other){
        const dx=this.x-other.x; const dy=this.y-other.y; const dist=Math.sqrt(dx*dx+dy*dy); return dist<this.radius+other.radius;
    }
}

function spawnRandomCircle(team){ const x=Math.random()*(canvas.width-40)+20; const y=Math.random()*(canvas.height-40)+20; circles.push(new Circle(x,y,team)); updateCounts(); }

function updateCounts(){ blueCountElement.textContent=circles.filter(c=>c.team==='blue').length; redCountElement.textContent=circles.filter(c=>c.team==='red').length; }

function clearAll(){ circles=[]; selectedCircle=null; playerKills=0; aiKills=0; playerKillsElement.textContent=0; aiKillsElement.textContent=0; gameStartTime=Date.now(); }

function setDifficulty(level){ difficulty=level; for(const [k,b] of Object.entries(difficultyButtons)){ if(k===level)b.classList.add('active-difficulty'); else b.classList.remove('active-difficulty'); } }

canvas.addEventListener('click',(e)=>{
    const rect=canvas.getBoundingClientRect();
    const mx=e.clientX-rect.left; const my=e.clientY-rect.top;
    let clicked=null;
    for(const c of circles){ if(c.team==='blue'){ const dx=c.x-mx; const dy=c.y-my; if(Math.sqrt(dx*dx+dy*dy)<=c.radius){clicked=c; break;} } }
    if(clicked) selectedCircle=clicked;
    else if(selectedCircle) selectedCircle.setTarget(mx,my);
});

spawnBlueButton.addEventListener('click',()=>spawnRandomCircle('blue'));
spawnRedButton.addEventListener('click',()=>spawnRandomCircle('red'));
clearAllButton.addEventListener('click',clearAll);
for(const [key,btn] of Object.entries(difficultyButtons)){ btn.addEventListener('click',()=>setDifficulty(key)); }

function gameLoop(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for(let i=0;i<circles.length;i++){
        const c=circles[i]; c.move();
        for(let j=0;j<circles.length;j++){ if(i!==j){ const o=circles[j]; const dx=c.x-o.x; const dy=c.y-o.y; const dist=Math.sqrt(dx*dx+dy*dy); const minDist=c.radius+o.radius; if(dist<minDist && dist>0){ const overlap=minDist-dist; const nx=dx/dist; const ny=dy/dist; c.x+=nx*(overlap/2); c.y+=ny*(overlap/2); o.x-=nx*(overlap/2); o.y-=ny*(overlap/2); } } }
        for(let j=0;j<circles.length;j++){ if(i!==j && c.team!==circles[j].team && c.isCollidingWith(circles[j])){ c.attack(circles[j]); } }
        c.draw();
    }
    circles=circles.filter(c=>c.health>0);
    updateCounts();
    gameTime=Math.floor((Date.now()-gameStartTime)/1000); gameTimeElement.textContent=gameTime;
    requestAnimationFrame(gameLoop);
}

for(let i=0;i<5;i++){ spawnRandomCircle('blue'); spawnRandomCircle('red'); }
gameLoop();
</script>
</body>
</html>
