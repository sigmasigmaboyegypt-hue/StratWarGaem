<!DOCTYPE html>
<html>
<head>
    <title>RTS Game with Collision & Health Bars</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            color: white;
            overflow: hidden;
        }
        #gameCanvas {
            border: 2px solid #444;
            background: #2a2a2a;
            cursor: crosshair;
        }
        .ui {
            margin-bottom: 10px;
            display: flex;
            gap: 20px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="ui">
        <div>Blue: <span id="blueCount">0</span></div>
        <div>Red: <span id="redCount">0</span></div>
        <div>Selected: <span id="selectedCount">0</span></div>
    </div>
    <canvas id="gameCanvas" width="1000" height="800"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const UNIT_RADIUS = 12;
        const SELECT_RADIUS = 16;
        const DETECTION_RANGE = 120;
        const MAX_SPEED = 2.5;
        const SEPARATION = 20;

        let blueUnits = [];
        let redUnits = [];
        let selectedUnits = [];
        let isSelecting = false;
        let selectionStart = { x: 0, y: 0 };
        let selectionEnd = { x: 0, y: 0 };

        class Unit {
            constructor(x, y, isBlue) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.targetX = null;
                this.targetY = null;
                this.isBlue = isBlue;
                this.selected = false;
                this.target = null;
                this.wanderTimer = 0;

                this.maxHp = 100;
                this.hp = this.maxHp;
                this.damage = 20;
                this.attackCooldown = 0; // frames
            }

            update() {
                // Attack cooldown
                if(this.attackCooldown > 0) this.attackCooldown--;

                if (this.isBlue) this.updateBlue();
                else this.updateRed();

                // Move unit
                this.x += this.vx;
                this.y += this.vy;

                // Keep inside canvas
                this.x = Math.max(UNIT_RADIUS, Math.min(canvas.width - UNIT_RADIUS, this.x));
                this.y = Math.max(UNIT_RADIUS, Math.min(canvas.height - UNIT_RADIUS, this.y));

                this.applySeparation();
                this.limitSpeed();
            }

            updateBlue() {
                const enemy = this.findNearestEnemy();
                if (enemy && this.distanceTo(enemy) < DETECTION_RANGE) {
                    this.target = enemy;
                    this.moveToward(enemy.x, enemy.y);

                    if(this.distanceTo(enemy) <= UNIT_RADIUS*2 && this.attackCooldown <= 0){
                        enemy.hp -= this.damage;
                        this.attackCooldown = 60; // 1 second at 60fps
                        if(enemy.hp <= 0){
                            const index = redUnits.indexOf(enemy);
                            if(index>-1) redUnits.splice(index,1);
                        }
                    }

                } else if(this.targetX !== null) {
                    this.moveToward(this.targetX, this.targetY);
                    if(this.distanceTo({x:this.targetX,y:this.targetY}) < UNIT_RADIUS) {
                        this.targetX = null;
                        this.targetY = null;
                    }
                } else {
                    this.vx *= 0.8;
                    this.vy *= 0.8;
                }
            }

            updateRed() {
                const enemy = this.findNearestEnemy();
                if (enemy && this.distanceTo(enemy) < DETECTION_RANGE) {
                    this.moveToward(enemy.x, enemy.y);

                    if(this.distanceTo(enemy) <= UNIT_RADIUS*2 && this.attackCooldown <=0){
                        enemy.hp -= this.damage;
                        this.attackCooldown = 60;
                        if(enemy.hp <=0){
                            const index = blueUnits.indexOf(enemy);
                            if(index>-1) blueUnits.splice(index,1);
                        }
                    }

                } else {
                    this.wander();
                }
            }

            wander() {
                this.wanderTimer--;
                if(this.wanderTimer<=0){
                    const angle = Math.random()*Math.PI*2;
                    this.vx += Math.cos(angle)*0.3;
                    this.vy += Math.sin(angle)*0.3;
                    this.wanderTimer = 60 + Math.random()*60;
                }
            }

            moveToward(tx, ty){
                const dx = tx - this.x;
                const dy = ty - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if(dist>0.5){
                    this.vx = (dx/dist)*MAX_SPEED;
                    this.vy = (dy/dist)*MAX_SPEED;
                } else {
                    this.vx = 0;
                    this.vy = 0;
                }
            }

            applySeparation(){
                const units = this.isBlue ? blueUnits : redUnits;
                for(const other of units){
                    if(other===this) continue;
                    const dx = this.x - other.x;
                    const dy = this.y - other.y;
                    const dist = Math.sqrt(dx*dx+dy*dy);
                    if(dist<SEPARATION && dist>0){
                        const push = (SEPARATION-dist)/SEPARATION;
                        this.vx += (dx/dist)*push*1.5;
                        this.vy += (dy/dist)*push*1.5;
                    }
                }
            }

            limitSpeed(){
                const speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
                if(speed>MAX_SPEED){
                    this.vx = (this.vx/speed)*MAX_SPEED;
                    this.vy = (this.vy/speed)*MAX_SPEED;
                }
            }

            findNearestEnemy(){
                const enemies = this.isBlue ? redUnits : blueUnits;
                let nearest = null;
                let nearestDist = Infinity;
                for(const enemy of enemies){
                    const d = this.distanceTo(enemy);
                    if(d<nearestDist){
                        nearestDist = d;
                        nearest = enemy;
                    }
                }
                return nearest;
            }

            distanceTo(other){
                const dx = this.x - other.x;
                const dy = this.y - other.y;
                return Math.sqrt(dx*dx + dy*dy);
            }

            draw(){
                ctx.save();
                if(this.selected){
                    ctx.strokeStyle = '#0ff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x,this.y,SELECT_RADIUS,0,Math.PI*2);
                    ctx.stroke();
                }
                ctx.fillStyle = this.isBlue ? '#48f' : '#f44';
                ctx.beginPath();
                ctx.arc(this.x,this.y,UNIT_RADIUS,0,Math.PI*2);
                ctx.fill();

                // Draw health bar only if damaged
                if(this.hp < this.maxHp){
                    const barWidth = UNIT_RADIUS*2;
                    const barHeight = 4;
                    const hpPercent = Math.max(0,this.hp/this.maxHp);
                    ctx.fillStyle = '#333';
                    ctx.fillRect(this.x-barWidth/2,this.y-UNIT_RADIUS-8,barWidth,barHeight);
                    ctx.fillStyle = hpPercent>0.6?'#4f4': hpPercent>0.3?'#ff4':'#f44';
                    ctx.fillRect(this.x-barWidth/2,this.y-UNIT_RADIUS-8,barWidth*hpPercent,barHeight);
                }

                ctx.restore();
            }
        }

        function initGame(){
            for(let i=0;i<8;i++){
                blueUnits.push(new Unit(100+Math.random()*150,100+Math.random()*150,true));
            }
            for(let i=0;i<10;i++){
                redUnits.push(new Unit(600+Math.random()*150,500+Math.random()*150,false));
            }
            updateUI();
        }

        function gameLoop(){
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(0,0,canvas.width,canvas.height);

            blueUnits.forEach(u=>u.update());
            redUnits.forEach(u=>u.update());

            blueUnits.forEach(u=>u.draw());
            redUnits.forEach(u=>u.draw());

            if(isSelecting) drawSelection();

            updateUI();
            requestAnimationFrame(gameLoop);
        }

        function drawSelection(){
            ctx.save();
            ctx.strokeStyle='#0ff';
            ctx.fillStyle='rgba(0,255,255,0.1)';
            ctx.lineWidth=1;
            const x=Math.min(selectionStart.x,selectionEnd.x);
            const y=Math.min(selectionStart.y,selectionEnd.y);
            const w=Math.abs(selectionEnd.x-selectionStart.x);
            const h=Math.abs(selectionEnd.y-selectionStart.y);
            ctx.fillRect(x,y,w,h);
            ctx.strokeRect(x,y,w,h);
            ctx.restore();
        }

        function updateUI(){
            document.getElementById('blueCount').textContent=blueUnits.length;
            document.getElementById('redCount').textContent=redUnits.length;
            document.getElementById('selectedCount').textContent=selectedUnits.length;
        }

        function getMousePos(e){
            const rect=canvas.getBoundingClientRect();
            return {x:e.clientX-rect.left, y:e.clientY-rect.top};
        }

        function selectInRect(rect){
            selectedUnits=[];
            const x1=Math.min(rect.startX,rect.endX);
            const x2=Math.max(rect.startX,rect.endX);
            const y1=Math.min(rect.startY,rect.endY);
            const y2=Math.max(rect.startY,rect.endY);
            blueUnits.forEach(u=>{
                u.selected=false;
                if(u.x>=x1 && u.x<=x2 && u.y>=y1 && u.y<=y2){
                    u.selected=true;
                    selectedUnits.push(u);
                }
            });
        }

        function moveSelected(x,y){
            if(!selectedUnits.length) return;
            const cols=Math.ceil(Math.sqrt(selectedUnits.length));
            const spacing=UNIT_RADIUS*3;
            selectedUnits.forEach((u,i)=>{
                const row=Math.floor(i/cols);
                const col=i%cols;
                const offsetX=(col-(cols-1)/2)*spacing;
                const offsetY=(row-(cols-1)/2)*spacing;
                u.targetX = x+offsetX;
                u.targetY = y+offsetY;
                u.target=null;
            });
        }

        canvas.addEventListener('mousedown', e=>{
            const pos=getMousePos(e);
            if(e.button===0){
                isSelecting=true;
                selectionStart={...pos};
                selectionEnd={...pos};
            }
        });

        canvas.addEventListener('mousemove', e=>{
            if(isSelecting) selectionEnd=getMousePos(e);
        });

        canvas.addEventListener('mouseup', e=>{
            if(e.button===0 && isSelecting){
                isSelecting=false;
                selectInRect({startX:selectionStart.x,startY:selectionStart.y,endX:selectionEnd.x,endY:selectionEnd.y});
            }
        });

        canvas.addEventListener('contextmenu', e=>{
            e.preventDefault();
            const pos=getMousePos(e);
            moveSelected(pos.x,pos.y);
        });

        initGame();
        gameLoop();
    </script>
</body>
</html>
